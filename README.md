# Реализация калькулятора для RPN-выражений на Python

## Введение
Выбранная структура - М3. Задача: написать пользовательский калькулятор с расширенной поддержкой вычислительных функций (+, -, *, /, **, %, //), унарных операторов (~ - унарный минус и $ - унарный плюс) и скобок.
Данная версия калькулятора была реализована через несколько функций: tokenize_rpn (разбиение выражения на токены и добавление их в список), is_valid_rpn_expression и is_valid_rpn_expression_final (проверка корректности введенного выражения с поднятием ошибки в случае некорректности), is_number (проверка, является ли токен числом) и calculate_expression (подсчет финального результата). Выполнено без сторонних библиотек.

## Схема работы
Пользователь вводит свое выражение уже записанным в обратной польской нотации. Токены считываются, определяется их тип (скобка, унарный оператор, бинарный оператор или число) и добавляется в стек. Неизвестный токен не считывается функцией, вместо этого вызывается ошибка с пояснением, какой именно токен не был распознан. После успешного считывания всех токенов выражение проходит проверку на корректность (правильно ли расставлены между собой операторы и числа, все ли скобки открыты/закрыты, корректно ли расставлены унарные знаки). Выражение в скобках перед считыванием также отдельно проходит проверку на корректность. 
Если выражение верно, оно передается в функцию calculate_expression, где поочередно производится подсчет. Цикл проходит по стеку, берет первые 2 числа и оператор, производится операция, после чего ответ кладется обратно в стек, затем цикл снова проходит по выражению - и так далее, пока в стеке не останется одно число. Оно и выводится в качестве ответа. При некорректной операции (деление на ноль) подсчет не производится, вместо этого выводится ошибка с пояснением, какое именно действие ее вызвало.

## Пользовательские допущения
1. Унарный оператор ($ или ~) всегда вводится **после числа/скобки** (по стандартным правилам обратной польской записи) и **через пробел**, как и все остальные токены. В противном случае пользователю выводится ошибка.
1.1. Возможно введение унарного плюса или минуса перед числом по стандартным математическим правилам (например, -5), но не поддерживается перед скобкой ( -( 5 2 * )). В таком случае нужно использовать тильду ( 5 2 * ) ~
2. Операции целочисленного деления (//) или вычисления остатка (%) неприменимы по отношению к нецелым числам (по условию).
3. Допускается вводить **любое количество вложенных скобок** (например, ( ( ( ( ( 5 2 + ) ) ) ) )), главное, чтобы выполнялась правильность выражения внутри них.
4. Пустые скобки **некорректны**, как и пустая строка на входе.
5. Если результат является комплексным числом, пользователю выведется ошибка (из-за некорректного отображения комплексных чисел в Python).
6. Пользователь должен любить котиков. (это обязательное требование, иначе калькулятор выводит ошибку)

## Структура файлов
**В папке src:**
1. constants.py - константы (в данном случае - списки допустимых унарных и бинарных операторов).
2. power.py - основные функции программы (их 5 - токенизатор, проверка токена на корректность числового значения, проверка корректности выражения в скобках, проверка всего стека на корректность выражения, подсчет результата).
3. main.py - входная точка калькулятора с функцией main, которая требует от пользователя ввод выражения и через импортированные из power.py функции считает результат и выводит его на экран. Ничего не возвращает.

**В папке tests:**
test_calculate.py - тестирует программу для разных типов заданных выражений. Проверяет как верные - на результат, так и заведомо ошибочные (разные типы ошибок). Реализован с помощью встроенной библиотеки pytest.

## На этом все! Удачного пользования!

<pre>

    /\___/\                     
   /       \
  l  u   u  l
--l----*----l--
   \   w   /     - Meow!   			
     ======					
   /       \ __					
   l        l\ \					
   l        l/ /   					
   l  l l   l /					
   \ ml lm /_/	

</pre>			
